<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šæ™ºèƒ½ä½“å¤´è„‘é£æš´ç³»ç»Ÿ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/force-graph"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Inter', system-ui, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .message-enter {
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .typing-indicator::after {
            content: '...';
            animation: typing 1s infinite;
        }

        @keyframes typing {

            0%,
            20% {
                content: '.';
            }

            40% {
                content: '..';
            }

            60%,
            100% {
                content: '...';
            }
        }

        .phase-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .facilitator-msg {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .agent-msg {
            background: rgba(255, 255, 255, 0.1);
            min-height: auto;
            height: auto;
        }

        .facilitator-msg {
            min-height: auto;
            height: auto;
        }

        .agent-msg .markdown-content,
        .facilitator-msg .markdown-content,
        .human-msg .markdown-content {
            min-height: auto;
            height: auto;
            max-height: none;
        }

        .summary-section {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Streaming cursor for messages being generated */
        .streaming-cursor::after {
            content: 'â–Š';
            animation: blink 0.8s infinite;
            margin-left: 2px;
        }

        @keyframes blink {

            0%,
            50% {
                opacity: 1;
            }

            51%,
            100% {
                opacity: 0;
            }
        }

        /* Markdown Styles */
        .markdown-content h1 {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 1rem 0 0.5rem;
        }

        .markdown-content h2 {
            font-size: 1.25rem;
            font-weight: bold;
            margin: 0.8rem 0 0.4rem;
            color: #a78bfa;
        }

        .markdown-content h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0.6rem 0 0.3rem;
        }

        .markdown-content p {
            margin: 0.4rem 0;
            line-height: 1.6;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .markdown-content {
            max-width: 100%;
            overflow-wrap: break-word;
        }

        .markdown-content ul,
        .markdown-content ol {
            margin: 0.4rem 0;
            padding-left: 1.5rem;
        }

        .markdown-content li {
            margin: 0.2rem 0;
        }

        .markdown-content code {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-size: 0.9em;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #2d3748;
        }

        ::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }

        /* Print Styles for Report */
        @media print {
            body * {
                visibility: hidden;
            }

            #report-content,
            #report-content * {
                visibility: visible;
            }

            #report-content {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                color: black !important;
                background: white !important;
                padding: 20px;
            }

            /* Hide modal buttons when printing */
            .no-print {
                display: none !important;
            }
        }

        .markdown-content pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.8rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.5rem 0;
        }

        .markdown-content blockquote {
            border-left: 3px solid #a78bfa;
            padding-left: 1rem;
            margin: 0.5rem 0;
            opacity: 0.9;
        }

        .markdown-content table {
            border-collapse: collapse;
            margin: 0.5rem 0;
            width: 100%;
        }

        .markdown-content th,
        .markdown-content td {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.4rem 0.6rem;
        }

        .markdown-content th {
            background: rgba(255, 255, 255, 0.1);
        }

        .mermaid {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            margin: 0.5rem 0;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            body {
                font-size: 14px;
            }

            .glass-card {
                border-radius: 12px;
            }

            /* Stack layout vertically on mobile */
            #app>div {
                flex-direction: column !important;
            }

            /* Full width panels on mobile */
            .w-80,
            .w-96 {
                width: 100% !important;
                max-width: 100% !important;
            }

            /* Adjust chat area for mobile */
            .flex-1 {
                min-height: 60vh;
            }

            /* Hide graph on very small screens, show as collapsible */
            @media (max-width: 640px) {
                .graph-container {
                    max-height: 300px;
                }
            }
        }

        /* Smooth scroll for chat */
        .chat-messages {
            scroll-behavior: smooth;
        }

        /* Code block styling for highlight.js */
        .markdown-content pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.8rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.5rem 0;
            max-width: 100%;
        }

        .markdown-content pre code {
            display: block;
            padding: 0;
            overflow-x: auto;
            border-radius: 6px;
            font-size: 0.9rem;
            line-height: 1.5;
            white-space: pre;
            word-wrap: normal;
        }

        /* Ensure tables don't overflow */
        .markdown-content table {
            border-collapse: collapse;
            margin: 0.5rem 0;
            width: 100%;
            display: block;
            overflow-x: auto;
        }

        /* Typing animation enhancement */
        @keyframes typewriter {
            from {
                width: 0;
            }

            to {
                width: 100%;
            }
        }

        .typewriter-text {
            overflow: hidden;
            white-space: nowrap;
        }
    </style>
</head>

<body class="text-white">
    <div id="app" class="h-screen flex flex-col">
        <!-- Header -->
        <header class="glass-card p-4 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <span class="text-2xl">ğŸ§ </span>
                <h1
                    class="text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                    å¤šæ™ºèƒ½ä½“å¤´è„‘é£æš´ç³»ç»Ÿ
                </h1>
                <button @click="createNewSession"
                    class="ml-4 px-3 py-1 bg-white/10 hover:bg-white/20 rounded-full text-xs transition border border-white/20 flex items-center gap-1">
                    <span>â•</span> æ–°å»ºä¼šè¯
                </button>
            </div>
            <div class="flex items-center gap-4">
                <div v-if="currentPhase" class="phase-badge px-3 py-1 rounded-full text-sm font-medium">
                    {{ phaseEmoji }} {{ phaseName }}
                </div>
                <div class="text-sm text-gray-400">
                    {{ sessionActive ? 'ğŸŸ¢ è¿›è¡Œä¸­' : 'âšª å¾…å¯åŠ¨' }}
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="flex-1 flex flex-col md:flex-row overflow-hidden p-2 md:p-4 gap-2 md:gap-4">
            <!-- Left Panel: Config & Agents -->
            <div
                class="w-full md:w-80 glass-card rounded-xl p-3 md:p-4 overflow-y-auto shrink-0 max-h-[50vh] md:max-h-none">
                <div v-if="!sessionActive">
                    <!-- Tabs -->
                    <div class="flex gap-2 mb-4 bg-white/5 p-1 rounded-lg">
                        <button
                            class="flex-1 py-1.5 text-xs font-medium rounded-md transition flex items-center justify-center gap-1"
                            :class="currentTab === 'config' ? 'bg-blue-600 shadow text-white' : 'hover:bg-white/10 text-gray-400'"
                            @click="currentTab = 'config'">
                            <span>âš™ï¸</span> é…ç½®
                        </button>
                        <button
                            class="flex-1 py-1.5 text-xs font-medium rounded-md transition flex items-center justify-center gap-1"
                            :class="currentTab === 'history' ? 'bg-blue-600 shadow text-white' : 'hover:bg-white/10 text-gray-400'"
                            @click="currentTab = 'history'; fetchSessions()">
                            <span>ğŸ“œ</span> å†å²è®°å½•
                        </button>
                    </div>

                    <!-- Config Tab -->
                    <div v-show="currentTab === 'config'">
                        <h2 class="text-lg font-semibold mb-4 flex items-center gap-2">
                            <span>âš™ï¸</span> ä¼šè¯é…ç½®
                        </h2>

                        <div class="mb-4">
                            <label class="block text-sm font-medium text-gray-300 mb-1">è®¨è®ºä¸»é¢˜</label>
                            <textarea v-model="topic" rows="2"
                                class="w-full bg-white/10 border border-white/20 rounded-lg p-2 text-white placeholder-gray-400"
                                placeholder="è¾“å…¥è®¨è®ºä¸»é¢˜..."></textarea>
                        </div>

                        <h3 class="text-md font-medium mb-2 flex items-center gap-2">
                            <span>ğŸ‘¥</span> å‚ä¸ä¸“å®¶ ({{ agents.length }})
                        </h3>

                        <div class="space-y-2 max-h-60 overflow-y-auto mb-4">
                            <div v-for="(agent, index) in agents" :key="index"
                                class="glass-card rounded-lg p-2 text-sm">
                                <div class="flex justify-between items-center">
                                    <span class="font-medium">{{ agent.name }}</span>
                                    <button @click="removeAgent(index)"
                                        class="text-red-400 hover:text-red-300">âœ•</button>
                                </div>
                                <div class="text-xs text-gray-400 mt-1">{{ agent.role }}</div>
                                <select v-model="agent.model_name"
                                    class="w-full bg-white/10 border border-white/20 rounded p-1 text-xs mt-1">
                                    <option v-for="model in availableModels" :key="model" :value="model">
                                        {{ model }}
                                    </option>
                                </select>
                            </div>
                        </div>

                        <button @click="showPresetModal = true"
                            class="w-full py-2 glass-card rounded-lg hover:bg-white/10 mb-4 text-sm">
                            â• æ·»åŠ ä¸“å®¶
                        </button>

                        <!-- Phase Rounds Configuration -->
                        <div class="mb-4">
                            <h3 class="text-md font-medium mb-2 flex items-center gap-2">
                                <span>ğŸ”„</span> é˜¶æ®µè½®æ•°é…ç½®
                            </h3>
                            <div class="space-y-2 text-sm">
                                <template v-for="phase in phases" :key="phase.id">
                                    <div v-if="phase.defaultRounds > 0"
                                        class="flex items-center justify-between p-2 glass-card rounded">
                                        <span>{{ phase.emoji }} {{ phase.name }}</span>
                                        <div class="flex items-center gap-2">
                                            <button @click="decreaseRounds(phase.id)"
                                                class="w-6 h-6 bg-white/10 rounded hover:bg-white/20">-</button>
                                            <span class="w-6 text-center">{{ phaseRounds[phase.id] ||
                                                phase.defaultRounds
                                                }}</span>
                                            <button @click="increaseRounds(phase.id)"
                                                class="w-6 h-6 bg-white/10 rounded hover:bg-white/20">+</button>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </div>

                        <button @click="startFullSession" :disabled="loading || agents.length === 0"
                            class="w-full py-3 bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg font-bold hover:opacity-90 disabled:opacity-50">
                            ğŸš€ å¯åŠ¨å¤´è„‘é£æš´
                        </button>
                    </div>

                    <!-- History Tab -->
                    <div v-show="currentTab === 'history'">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-lg font-semibold flex items-center gap-2">
                                <span>ğŸ“œ</span> å†å²ä¼šè¯
                            </h2>
                            <button @click="fetchSessions"
                                class="text-xs bg-white/10 px-2 py-1 rounded hover:bg-white/20">ğŸ”„ åˆ·æ–°</button>
                        </div>

                        <div v-if="pastSessions.length === 0" class="text-center text-gray-500 py-10">
                            æš‚æ— å†å²è®°å½•
                        </div>

                        <div class="space-y-3 max-h-[70vh] overflow-y-auto">
                            <div v-for="session in pastSessions" :key="session.id"
                                @click="loadSessionHistory(session.id)"
                                class="glass-card p-3 rounded-lg cursor-pointer hover:bg-white/10 transition active:scale-95 group">
                                <div class="font-medium mb-1 line-clamp-2 group-hover:text-blue-300 transition-colors">
                                    {{ session.topic }}</div>
                                <div class="flex justify-between text-xs text-gray-400">
                                    <span>ğŸ§  {{ session.agent_count }} ä¸“å®¶</span>
                                    <span>{{ new Date(session.created_at).toLocaleString() }}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div v-else>
                    <h2 class="text-lg font-semibold mb-4">ğŸ“‹ ä¼šè®®è¿›ç¨‹</h2>

                    <!-- Phase Progress -->
                    <div class="space-y-2 mb-6">
                        <div v-for="phase in phases" :key="phase.id" :class="['p-2 rounded-lg text-sm flex items-center gap-2', 
                                      phase.id === currentPhase ? 'bg-purple-500/30 border border-purple-500' : 
                                      completedPhases.includes(phase.id) ? 'bg-green-500/20' : 'bg-white/5']">
                            <span>{{ phase.emoji }}</span>
                            <span>{{ phase.name }}</span>
                            <span v-if="phase.id === currentPhase && loading"
                                class="ml-auto text-yellow-400 pulse">â—</span>
                            <span v-else-if="completedPhases.includes(phase.id)" class="ml-auto text-green-400">âœ“</span>
                        </div>
                    </div>

                    <h3 class="text-md font-medium mb-2">ğŸ‘¥ å‚ä¸ä¸“å®¶</h3>
                    <div class="space-y-1 text-sm">
                        <div v-for="agent in activeAgents" :key="agent.name"
                            class="flex items-center gap-2 p-2 bg-white/5 rounded">
                            <span :class="typingAgent === agent.name ? 'animate-pulse' : ''">
                                {{ typingAgent === agent.name ? 'ğŸ’­' : 'ğŸ‘¤' }}
                            </span>
                            <span>{{ agent.name }}</span>
                            <span class="text-xs text-gray-400 ml-auto">{{ agent.emotion }}</span>
                        </div>
                    </div>

                    <!-- Control Buttons -->
                    <div class="mt-6 space-y-2">
                        <button @click="togglePause"
                            :class="['w-full py-2 rounded-lg font-medium transition', 
                                     isPaused ? 'bg-green-500 hover:bg-green-600' : 'bg-yellow-500 hover:bg-yellow-600']">
                            {{ isPaused ? 'â–¶ï¸ ç»§ç»­' : 'â¸ï¸ æš‚åœ' }}
                        </button>
                        <button @click="resetSession"
                            class="w-full py-2 bg-red-500/80 hover:bg-red-500 rounded-lg font-medium transition">
                            ğŸ”„ é‡ç½®ä¼šè¯
                        </button>
                        <div class="border-t border-white/10 pt-2 mt-2">
                            <p class="text-xs text-gray-400 mb-2">ğŸ“¤ å¯¼å‡ºåŠŸèƒ½</p>
                            <button @click="exportSummaryMD" :disabled="!hasSummary"
                                class="w-full py-2 bg-blue-500/80 hover:bg-blue-500 disabled:opacity-40 rounded-lg font-medium transition mb-2">
                                ğŸ“„ é¢„è§ˆ/å¯¼å‡ºæ–¹æ¡ˆ(MD)
                            </button>
                            <button @click="exportGraphMermaid" :disabled="graphData.nodes.length === 0"
                                class="w-full py-2 bg-purple-500/80 hover:bg-purple-500 disabled:opacity-40 rounded-lg font-medium transition">
                                ğŸ”® å¯¼å‡ºå›¾è°±(Mermaid)
                            </button>
                            <button @click="exportMindMap" :disabled="graphData.nodes.length === 0"
                                class="w-full mt-2 py-2 bg-indigo-500/80 hover:bg-indigo-500 disabled:opacity-40 rounded-lg font-medium transition">
                                ğŸ§  å¯¼å‡ºæ€ç»´å¯¼å›¾
                            </button>
                            <button @click="exportGraphImage" :disabled="graphData.nodes.length === 0"
                                class="w-full mt-2 py-2 bg-pink-600/80 hover:bg-pink-600 disabled:opacity-40 rounded-lg font-medium transition flex items-center justify-center">
                                <span class="mr-2">ğŸ“¸</span> å¯¼å‡ºå›¾è°±(PNG)
                            </button>
                            <button @click="exportFullChat" :disabled="messages.length === 0"
                                class="w-full mt-2 py-2 bg-gray-600/80 hover:bg-gray-600 disabled:opacity-40 rounded-lg font-medium transition flex items-center justify-center">
                                <span class="mr-2">ğŸ’¬</span> å¯¼å‡ºå®Œæ•´å¯¹è¯
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Middle Panel: Chat -->
            <div class="flex-1 glass-card rounded-xl flex flex-col">
                <div class="p-4 border-b border-white/10">
                    <h2 class="font-semibold">ğŸ’¬ è®¨è®ºåŒº</h2>
                    <p class="text-sm text-gray-400">{{ topic || 'ç­‰å¾…ä¼šè®®å¼€å§‹...' }}</p>
                </div>

                <div class="flex-1 overflow-y-auto p-4 space-y-3" id="chat-container">
                    <div v-for="(msg, idx) in messages" :key="idx" class="message-enter">
                        <!-- Facilitator Message -->
                        <div v-if="msg.type === 'facilitator'"
                            class="facilitator-msg rounded-xl p-4 max-w-full md:max-w-4xl">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="text-lg">ğŸ™ï¸</span>
                                <span class="font-bold">ä¸»æŒäºº</span>
                                <span class="text-xs bg-white/20 px-2 py-0.5 rounded-full">{{ msg.phase_name }}</span>
                            </div>
                            <div class="markdown-content" v-html="renderMarkdown(msg.content)"></div>
                        </div>
                        <div v-if="msg.type === 'agent'"
                            class="agent-msg rounded-xl p-4 max-w-full md:max-w-4xl ml-0 md:ml-8">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="text-lg">ğŸ‘¤</span>
                                <span class="font-bold">{{ msg.sender }}</span>
                                <span class="text-xs bg-blue-500/30 px-2 py-0.5 rounded-full">{{ msg.role }}</span>
                                <span class="text-xs text-gray-400 ml-auto">{{ msg.model }}</span>
                                <span v-if="msg.streaming" class="text-xs text-yellow-400 ml-2">âš¡ ç”Ÿæˆä¸­...</span>
                            </div>
                            <div class="markdown-content" :class="{'streaming-cursor': msg.streaming}"
                                v-html="renderMarkdown(msg.content)"></div>
                        </div>
                        <div v-if="msg.type === 'human'"
                            class="human-msg rounded-xl p-4 max-w-full md:max-w-3xl ml-auto bg-blue-600/30 border border-blue-500/50">
                            <div class="flex items-center gap-2 mb-2 justify-end">
                                <span class="font-bold">{{ msg.sender }}</span>
                                <span class="text-lg">ğŸ—£ï¸</span>
                            </div>
                            <div class="markdown-content whitespace-pre-wrap" v-text="msg.content"></div>
                        </div>
                        <div v-if="msg.type === 'summary'" class="summary-section rounded-xl p-4 mt-4">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="text-lg">ğŸ“‹</span>
                                <span class="font-bold">åˆ›æ–°æ–¹æ¡ˆæŠ¥å‘Š</span>
                            </div>
                            <div class="markdown-content text-sm" v-html="renderMarkdown(msg.content)"></div>
                        </div>
                        <div v-if="msg.type === 'phase'" class="text-center py-2">
                            <span class="bg-purple-500/30 px-4 py-1 rounded-full text-sm">
                                {{ msg.emoji }} {{ msg.content }}
                            </span>
                        </div>
                    </div>

                    <!-- Typing Indicator -->
                    <div v-if="typingAgent"
                        class="agent-msg rounded-xl p-4 max-w-full md:max-w-4xl ml-0 md:ml-8 opacity-70">
                        <div class="flex items-center gap-2">
                            <span class="text-lg">ğŸ’­</span>
                            <span class="font-medium">{{ typingAgent }}</span>
                            <span class="typing-indicator">æ­£åœ¨æ€è€ƒ</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Visualization & Stats -->
            <div
                class="w-full md:w-80 glass-card rounded-xl p-3 md:p-4 flex flex-col overflow-y-auto shrink-0 max-h-[50vh] md:max-h-none">
                <!-- Online Users -->
                <div v-if="onlineUsers.length > 0" class="mb-4">
                    <h2 class="font-semibold mb-2 flex items-center gap-2">
                        <span>ğŸ‘¥</span> åœ¨çº¿ç”¨æˆ· ({{ onlineUsers.length }})
                    </h2>
                    <div class="flex flex-wrap gap-2">
                        <span v-for="user in onlineUsers" :key="user.user_id"
                            class="px-2 py-1 bg-green-500/20 rounded-full text-xs">
                            ğŸŸ¢ {{ user.name }}
                        </span>
                    </div>
                </div>

                <!-- Knowledge Graph -->
                <h2 class="font-semibold mb-2">ğŸ”— çŸ¥è¯†å›¾è°±</h2>
                <div id="graph" class="h-48 rounded-lg bg-black/30 overflow-hidden">
                    <div v-if="!graphData.nodes || graphData.nodes.length === 0"
                        class="h-full flex items-center justify-center text-gray-500 text-sm">
                        ç­‰å¾…è®¨è®ºå¼€å§‹...
                    </div>
                </div>

                <!-- Statistics Panel -->
                <div class="mt-4">
                    <h2 class="font-semibold mb-2 flex items-center gap-2">
                        <span>ğŸ“Š</span> ä¼šè¯ç»Ÿè®¡
                    </h2>
                    <div class="space-y-2 text-sm">
                        <div class="flex justify-between">
                            <span class="text-gray-400">æ¶ˆæ¯æ€»æ•°</span>
                            <span>{{ statistics.overview?.total_messages || messages.length }}</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">å‚ä¸æ™ºèƒ½ä½“</span>
                            <span>{{ statistics.overview?.total_agents || agents.length }}</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">é˜¶æ®µå®Œæˆ</span>
                            <span>{{ completedPhases.length }}/7</span>
                        </div>

                        <!-- Participation Chart -->
                        <div v-if="Object.keys(statistics.participation || {}).length > 0" class="mt-3">
                            <div class="text-xs text-gray-400 mb-1">å‚ä¸åº¦åˆ†å¸ƒ</div>
                            <div v-for="(percent, agent) in statistics.participation" :key="agent" class="mb-1">
                                <div class="flex justify-between text-xs mb-0.5">
                                    <span>{{ agent }}</span>
                                    <span>{{ percent }}%</span>
                                </div>
                                <div class="h-1.5 bg-white/10 rounded-full overflow-hidden">
                                    <div class="h-full bg-gradient-to-r from-blue-500 to-purple-500 rounded-full"
                                        :style="{width: percent + '%'}"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Top Keywords -->
                        <div v-if="Object.keys(statistics.top_keywords || {}).length > 0" class="mt-3">
                            <div class="text-xs text-gray-400 mb-1">çƒ­é—¨å…³é”®è¯</div>
                            <div class="flex flex-wrap gap-1">
                                <span v-for="(count, kw) in statistics.top_keywords" :key="kw"
                                    class="px-2 py-0.5 bg-purple-500/20 rounded text-xs">
                                    {{ kw }} ({{ count }})
                                </span>
                            </div>
                        </div>
                    </div>

                    <!-- Refresh Stats Button -->
                    <button @click="fetchStatistics"
                        class="w-full mt-3 py-1.5 glass-card rounded text-xs hover:bg-white/10">
                        ğŸ”„ åˆ·æ–°ç»Ÿè®¡
                    </button>
                </div>

                <!-- @Mention Input -->
                <div v-if="sessionActive" class="mt-4 border-t border-white/10 pt-4">
                    <h2 class="font-semibold mb-2 flex items-center gap-2">
                        <span>ğŸ’¬</span> å‚ä¸è®¨è®º
                    </h2>
                    <div class="text-xs text-gray-400 mb-2">
                        ä½¿ç”¨ @æ™ºèƒ½ä½“åç§° å¯ä»¥ç›´æ¥æé—®
                    </div>
                    <input v-model="userName" placeholder="ä½ çš„æ˜µç§°"
                        class="w-full bg-white/10 border border-white/20 rounded px-2 py-1.5 text-sm mb-2">
                    <textarea v-model="userMessage" @keyup.enter.prevent="sendMentionMessage"
                        placeholder="è¾“å…¥æ¶ˆæ¯... (ä¾‹å¦‚: @äº§å“ç»ç† ä½ æ€ä¹ˆçœ‹?)" rows="2"
                        class="w-full bg-white/10 border border-white/20 rounded px-2 py-1.5 text-sm resize-none"></textarea>
                    <button @click="sendMentionMessage"
                        class="w-full mt-2 py-2 bg-gradient-to-r from-green-500 to-teal-500 rounded font-medium text-sm hover:opacity-90 active:scale-95 transition-transform">
                        ğŸ“¤ å‘é€æ¶ˆæ¯
                    </button>
                </div>
            </div>
        </div>

        <!-- Expert Selection Modal -->
        <div v-if="showPresetModal" class="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
            <div class="glass-card rounded-2xl p-6 w-3/4 max-h-[80vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">é€‰æ‹©ä¸“å®¶è§’è‰²</h2>
                    <button @click="showPresetModal = false"
                        class="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>
                <div class="grid grid-cols-4 gap-3">
                    <div v-for="(preset, idx) in expertPresets" :key="idx" @click="addPresetAgent(preset)"
                        class="p-3 glass-card rounded-lg cursor-pointer hover:bg-white/10 transition">
                        <div class="font-bold text-sm">{{ preset.name }}</div>
                        <div class="text-xs text-gray-400 truncate">{{ preset.expertise }}</div>
                    </div>
                </div>
            </div>
        </div>


        <!-- Report Preview Modal -->
        <teleport to="body">
            <div v-if="showReportModal"
                class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-[1000]">
                <div
                    class="bg-gray-800 rounded-lg w-full max-w-4xl h-[90vh] flex flex-col shadow-2xl border border-gray-700">
                    <div
                        class="flex justify-between items-center p-4 border-b border-gray-700 bg-gray-900 rounded-t-lg no-print">
                        <h3
                            class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-400">
                            ğŸ“„ åˆ›æ–°æ–¹æ¡ˆæŠ¥å‘Šé¢„è§ˆ
                        </h3>
                        <button @click="showReportModal = false"
                            class="text-gray-400 hover:text-white transition-colors">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M6 18L18 6M6 6l12 12">
                                </path>
                            </svg>
                        </button>
                    </div>

                    <div class="flex-1 overflow-y-auto p-8 bg-white text-gray-900" id="report-content">
                        <!-- Rendered Markdown Report -->
                        <div class="prose prose-lg max-w-none" v-html="renderMarkdown(reportContent)"></div>

                        <hr class="my-8 border-gray-300" />

                        <div class="text-sm text-gray-500 text-center">
                            <p>ç”Ÿæˆäº Multi-Agent Brainstorming System</p>
                            <p>{{ new Date().toLocaleString() }}</p>
                        </div>
                    </div>

                    <div
                        class="p-4 border-t border-gray-700 bg-gray-900 rounded-b-lg flex justify-end space-x-4 no-print">
                        <button @click="downloadPDF"
                            class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg transition-colors flex items-center">
                            <span class="mr-2">ğŸ“„</span> ä¸‹è½½ PDF (ä¸“ä¸šç‰ˆ)
                        </button>
                        <button @click="printReport"
                            class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors flex items-center">
                            <span class="mr-2">ğŸ–¨ï¸</span> æµè§ˆå™¨æ‰“å°
                        </button>
                        <button @click="downloadMarkdown"
                            class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg transition-colors flex items-center">
                            <span class="mr-2">â¬‡ï¸</span> ä¸‹è½½ Markdown
                        </button>
                        <button @click="showReportModal = false"
                            class="px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors">
                            å…³é—­
                        </button>
                    </div>
                </div>
            </div>
        </teleport>

    </div>
    <script>
        const { createApp, ref, onMounted, nextTick, computed } = Vue;

        const app = createApp({
            setup() {
                const sessionActive = ref(false);
                const loading = ref(false);
                const topic = ref("æ™ºèƒ½å®¶ç”µäº§å“åˆ›æ–°æ–¹æ¡ˆ");
                const messages = ref([]);
                const typingAgent = ref(null);
                const currentPhase = ref(null);
                const phaseName = ref("");
                const phaseEmoji = ref("");
                const completedPhases = ref([]);
                const activeAgents = ref([]);
                const graphData = ref({ nodes: [], links: [] });
                const showPresetModal = ref(false);
                const isPaused = ref(false);
                let graphInstance = null;
                let eventSource = null;

                // New feature state
                const statistics = ref({});
                const onlineUsers = ref([]);
                const userName = ref("ç”¨æˆ·" + Math.floor(Math.random() * 1000));
                const userMessage = ref("");
                let websocket = null;

                // Session Management
                const sessionId = ref(new URLSearchParams(window.location.search).get('room') || 'default');

                // Report Modal State
                const showReportModal = ref(false);
                const reportContent = ref("");

                // Available API Models
                const availableModels = ref(["gemini-3-pro-preview", "grok-4.1-fast", "gpt-5-mini", "gemini-2.5-flash", "gpt-4"]);

                const phases = ref([
                    { id: "opening", name: "å¯åŠ¨ä¼šè¯", emoji: "ğŸ¬", defaultRounds: 0 },
                    { id: "define_topic", name: "å®šä¹‰ä¸»é¢˜", emoji: "ğŸ¯", defaultRounds: 1 },
                    { id: "diverge", name: "å‘æ•£é˜¶æ®µ", emoji: "ğŸ’¡", defaultRounds: 2 },
                    { id: "deepen", name: "æ·±åŒ–é˜¶æ®µ", emoji: "ğŸ”", defaultRounds: 2 },
                    { id: "evaluate", name: "è¯„ä¼°é˜¶æ®µ", emoji: "âš–ï¸", defaultRounds: 1 },
                    { id: "integrate", name: "æ•´åˆé˜¶æ®µ", emoji: "ğŸ”—", defaultRounds: 1 },
                    { id: "output", name: "è¾“å‡ºæ–¹æ¡ˆ", emoji: "ğŸ“‹", defaultRounds: 0 }
                ]);

                // History Management
                const currentTab = ref('config'); // 'config' or 'history'
                const pastSessions = ref([]);

                const fetchSessions = async () => {
                    try {
                        const res = await fetch('/sessions');
                        const data = await res.json();
                        pastSessions.value = data.sessions;
                    } catch (e) {
                        console.error("Failed to fetch sessions:", e);
                    }
                };

                const loadSessionHistory = async (sid) => {
                    if (sessionActive.value && !confirm("å½“å‰æœ‰æ­£åœ¨è¿›è¡Œçš„ä¼šè¯ï¼Œç¡®å®šè¦åˆ‡æ¢å—ï¼Ÿ")) {
                        return;
                    }

                    try {
                        loading.value = true;
                        const res = await fetch(`/sessions/${sid}/history`);
                        if (!res.ok) throw new Error("Failed to load history");

                        const data = await res.json();

                        // Update state
                        topic.value = data.session.topic;
                        sessionId.value = data.session.id; // Switch ID
                        currentPhase.value = data.session.current_phase;

                        // Restore agents
                        agents.value = data.agents.map(a => ({
                            name: a.name,
                            role: a.role,
                            model_name: a.model,
                            expertise: "", // Not stored efficiently yet
                            style: "",
                            personality_traits: []
                        }));

                        // Restore messages
                        messages.value = data.history.map(m => ({
                            sender: m.sender,
                            content: m.content,
                            type: m.type,
                            role: m.role,
                            model: m.model,
                            phase_name: m.phase, // Should map back to name if possible, or just use value
                            streaming: false
                        }));

                        // Set active but maybe 'read-only' mode? 
                        // For now just show it.
                        sessionActive.value = true;

                        // Close sidebar on mobile if needed

                    } catch (e) {
                        console.error("Error loading history:", e);
                        alert("åŠ è½½å†å²ä¼šè¯å¤±è´¥");
                    } finally {
                        loading.value = false;
                    }
                };

                // Initial fetch
                onMounted(() => {
                    fetchSessions();
                    fetchModels();
                    fetchStatistics();

                    // If session ID in URL is not default, try to load it? 
                    // Or just let user click. 
                });

                // Phase rounds configuration
                const phaseRounds = ref({
                    define_topic: 1,
                    diverge: 2,
                    deepen: 2,
                    evaluate: 1,
                    integrate: 1
                });

                const increaseRounds = (phaseId) => {
                    if (!phaseRounds.value[phaseId]) {
                        const phase = phases.value.find(p => p.id === phaseId);
                        phaseRounds.value[phaseId] = phase ? phase.defaultRounds : 1;
                    }
                    if (phaseRounds.value[phaseId] < 5) {
                        phaseRounds.value[phaseId]++;
                    }
                };

                const decreaseRounds = (phaseId) => {
                    if (!phaseRounds.value[phaseId]) {
                        const phase = phases.value.find(p => p.id === phaseId);
                        phaseRounds.value[phaseId] = phase ? phase.defaultRounds : 1;
                    }
                    if (phaseRounds.value[phaseId] > 0) {
                        phaseRounds.value[phaseId]--;
                    }
                };

                const expertPresets = [
                    { name: "äº§å“ç»ç†", role: "Product Manager", expertise: "äº§å“è§„åˆ’ä¸å¸‚åœºåˆ†æ", style: "ç”¨æˆ·å¯¼å‘", personality_traits: ["æ´å¯ŸåŠ›å¼º", "åè°ƒèƒ½åŠ›å¼º"] },
                    { name: "ç”µæ§è½¯ä»¶ä¸“å®¶", role: "Electronics Control Software Expert", expertise: "ç”µæ§ç³»ç»Ÿè½¯ä»¶å¼€å‘", style: "ä¸¥è°¨", personality_traits: ["é€»è¾‘æ¸…æ™°", "æ³¨é‡å®‰å…¨"] },
                    { name: "åµŒå…¥å¼è½¯ä»¶ä¸“å®¶", role: "Embedded Software Expert", expertise: "åµŒå…¥å¼ç³»ç»Ÿå¼€å‘", style: "åº•å±‚æ€ç»´", personality_traits: ["èµ„æºæ•æ„Ÿ", "æ€§èƒ½ä¼˜åŒ–"] },
                    { name: "äº§å“ä¼åˆ’ä¸“å®¶", role: "Product Planning Expert", expertise: "äº§å“æˆ˜ç•¥ä¸è§„åˆ’", style: "å‰ç»æ€§", personality_traits: ["æˆ˜ç•¥çœ¼å…‰", "å¸‚åœºæ•é”"] },
                    { name: "IoTä¸“å®¶", role: "IoT Expert", expertise: "ç‰©è”ç½‘æŠ€æœ¯ä¸æ¶æ„", style: "ç³»ç»Ÿæ€§", personality_traits: ["è¿æ¥æ€ç»´", "å®‰å…¨æ„è¯†"] },
                    { name: "TRIZåˆ›æ–°ä¸“å®¶", role: "TRIZ Innovation Expert", expertise: "åˆ›æ–°æ–¹æ³•è®ºä¸ä¸“åˆ©è§„é¿", style: "çªç ´å¸¸è§„", personality_traits: ["åˆ›é€ æ€§", "ç³»ç»Ÿåˆ›æ–°"] },
                    { name: "çƒ­æŠ€æœ¯ä¸“å®¶", role: "Thermal Technology Expert", expertise: "çƒ­ç®¡ç†ä¸æ•£çƒ­æŠ€æœ¯", style: "ç‰©ç†å¯¼å‘", personality_traits: ["ç²¾ç¡®è®¡ç®—", "ä»¿çœŸèƒ½åŠ›"] },
                    { name: "æµä½“æŠ€æœ¯ä¸“å®¶", role: "Fluid Technology Expert", expertise: "æµä½“åŠ›å­¦ä¸ç®¡è·¯è®¾è®¡", style: "ç‰©ç†å»ºæ¨¡", personality_traits: ["CFDåˆ†æ", "å®éªŒéªŒè¯"] },
                    { name: "ç©ºæ°”åŠ¨åŠ›å­¦ä¸“å®¶", role: "Aerodynamics Expert", expertise: "æ°”æµè®¾è®¡ä¸é£é“ä¼˜åŒ–", style: "ä»¿çœŸé©±åŠ¨", personality_traits: ["æµåœºåˆ†æ", "å™ªå£°æ§åˆ¶"] },
                    { name: "ç»“æ„ä¸“å®¶", role: "Structural Expert", expertise: "æœºæ¢°ç»“æ„è®¾è®¡ä¸å¼ºåº¦åˆ†æ", style: "å¯é æ€§", personality_traits: ["CAEåˆ†æ", "DFM"] },
                    { name: "ç‡ƒçƒ§ä¸“å®¶", role: "Combustion Expert", expertise: "ç‡ƒçƒ§æŠ€æœ¯ä¸èƒ½æ•ˆä¼˜åŒ–", style: "èƒ½æºæ•ˆç‡", personality_traits: ["å®‰å…¨ç¬¬ä¸€", "æ•ˆç‡ä¼˜åŒ–"] },
                    { name: "ç¡¬ä»¶å·¥ç¨‹å¸ˆ", role: "Hardware Engineer", expertise: "ç”µè·¯è®¾è®¡ä¸PCBå¸ƒå±€", style: "å®é™…åº”ç”¨", personality_traits: ["åŠ¨æ‰‹èƒ½åŠ›å¼º", "é—®é¢˜è§£å†³"] },
                    { name: "è‡ªåª’ä½“è¿è¥ä¸“å®¶", role: "Social Media Expert", expertise: "å†…å®¹è¥é”€ä¸ç”¨æˆ·å¢é•¿", style: "åˆ›æ„é©±åŠ¨", personality_traits: ["å†…å®¹åˆ›ä½œ", "æ•°æ®åˆ†æ"] },
                    { name: "å£°å­¦æŠ€æœ¯ä¸“å®¶", role: "Acoustics Expert", expertise: "å™ªå£°æ§åˆ¶ä¸å£°å­¦è®¾è®¡", style: "ç”¨æˆ·ä½“éªŒ", personality_traits: ["å£°å­¦æµ‹é‡", "é™å™ªä¼˜åŒ–"] },
                    { name: "ç”µç£æŠ€æœ¯ä¸“å®¶", role: "Electromagnetic Expert", expertise: "ç”µç£å…¼å®¹ä¸EMIè®¾è®¡", style: "åˆè§„å¯¼å‘", personality_traits: ["EMCæµ‹è¯•", "é˜²æŠ¤è®¾è®¡"] },
                    { name: "ç”µæœºæŠ€æœ¯ä¸“å®¶", role: "Motor Technology Expert", expertise: "ç”µæœºè®¾è®¡ä¸æ§åˆ¶", style: "æ•ˆç‡ä¼˜å…ˆ", personality_traits: ["ç”µæœºé€‰å‹", "é©±åŠ¨ä¼˜åŒ–"] },
                    { name: "å˜é¢‘æŠ€æœ¯ä¸“å®¶", role: "Inverter Technology Expert", expertise: "å˜é¢‘æ§åˆ¶ä¸ç”µåŠ›ç”µå­", style: "èŠ‚èƒ½ç¯ä¿", personality_traits: ["åŠŸç‡ä¼˜åŒ–", "è°æ³¢æ§åˆ¶"] },
                    { name: "åˆ¶å†·æŠ€æœ¯ä¸“å®¶", role: "Refrigeration Expert", expertise: "åˆ¶å†·å¾ªç¯ä¸çƒ­æ³µæŠ€æœ¯", style: "èƒ½æ•ˆæ¯”", personality_traits: ["ç³»ç»Ÿä¼˜åŒ–", "ç¯ä¿å†·åª’"] },
                    { name: "æ§åˆ¶ç®—æ³•ä¸“å®¶", role: "Control Algorithm Expert", expertise: "PID/MPCç­‰æ§åˆ¶ç®—æ³•", style: "æ•°å­¦å»ºæ¨¡", personality_traits: ["ç²¾ç¡®æ§åˆ¶", "é²æ£’æ€§"] },
                    { name: "æ™ºèƒ½æŠ€æœ¯ä¸“å®¶", role: "Smart Technology Expert", expertise: "æ™ºèƒ½å®¶å±…ä¸è¯­éŸ³äº¤äº’", style: "ç”¨æˆ·å‹å¥½", personality_traits: ["äº¤äº’è®¾è®¡", "æ™ºèƒ½è”åŠ¨"] },
                    { name: "ä¼ æ„Ÿå™¨æŠ€æœ¯ä¸“å®¶", role: "Sensor Technology Expert", expertise: "ä¼ æ„Ÿå™¨é€‰å‹ä¸ä¿¡å·å¤„ç†", style: "æ•°æ®å‡†ç¡®", personality_traits: ["ç²¾åº¦åˆ†æ", "æŠ—å¹²æ‰°"] },
                    { name: "ææ–™å­¦ä¸“å®¶", role: "Materials Science Expert", expertise: "æ–°ææ–™åº”ç”¨ä¸å·¥è‰º", style: "æ€§èƒ½å¯¼å‘", personality_traits: ["ææ–™é€‰å‹", "æˆæœ¬å¹³è¡¡"] },
                    { name: "ç”µåŒ–å­¦ä¸“å®¶", role: "Electrochemistry Expert", expertise: "ç”µæ± æŠ€æœ¯ä¸ç”µåŒ–å­¦ååº”", style: "å®‰å…¨å¯é ", personality_traits: ["ç”µæ± ç®¡ç†", "å¯¿å‘½ä¼˜åŒ–"] },
                    { name: "å‡€æ°´æŠ€æœ¯ä¸“å®¶", role: "Water Purification Expert", expertise: "æ°´å¤„ç†ä¸æ»¤èŠ¯æŠ€æœ¯", style: "å¥åº·å®‰å…¨", personality_traits: ["è¿‡æ»¤æ•ˆç‡", "æ°´è´¨æ£€æµ‹"] },
                    { name: "è¥é”€ä¸“å®¶", role: "Marketing Expert", expertise: "å¸‚åœºç­–ç•¥ä¸å“ç‰Œæ¨å¹¿", style: "ç”¨æˆ·æ´å¯Ÿ", personality_traits: ["å¸‚åœºåˆ†æ", "æ¨å¹¿ç­–åˆ’"] },
                    { name: "å¥åº·è¥å…»ä¸“å®¶", role: "Health & Nutrition Expert", expertise: "å¥åº·é£Ÿå“ä¸è¥å…»ç§‘å­¦", style: "ç§‘å­¦ä¸¥è°¨", personality_traits: ["è¥å…»åˆ†æ", "å¥åº·å»ºè®®"] },
                    { name: "åŒ»ç–—é¢†åŸŸæŠ€æœ¯ä¸“å®¶", role: "Medical Technology Expert", expertise: "åŒ»ç–—è®¾å¤‡ä¸å¥åº·ç›‘æµ‹", style: "åˆè§„å®‰å…¨", personality_traits: ["æ³•è§„ç†Ÿæ‚‰", "ä¸´åºŠéªŒè¯"] },
                    { name: "é›·è¾¾æŠ€æœ¯ä¸“å®¶", role: "Radar Technology Expert", expertise: "é›·è¾¾æ„Ÿåº”ä¸æµ‹è·æŠ€æœ¯", style: "ä¿¡å·å¤„ç†", personality_traits: ["æ³¢å½¢è®¾è®¡", "ç›®æ ‡æ£€æµ‹"] },
                    { name: "è‡ªåŠ¨æ§åˆ¶æŠ€æœ¯ä¸“å®¶", role: "Automatic Control Expert", expertise: "è‡ªåŠ¨åŒ–ç³»ç»Ÿä¸PLC", style: "ç³»ç»Ÿé›†æˆ", personality_traits: ["å¯é æ€§", "ç»´æŠ¤æ€§"] },
                    { name: "æœºå™¨å­¦ä¹ ä¸“å®¶", role: "Machine Learning Expert", expertise: "MLæ¨¡å‹è®­ç»ƒä¸éƒ¨ç½²", style: "æ•°æ®é©±åŠ¨", personality_traits: ["æ¨¡å‹ä¼˜åŒ–", "è¾¹ç¼˜éƒ¨ç½²"] },
                    { name: "AIæŠ€æœ¯ä¸“å®¶", role: "AI Technology Expert", expertise: "äººå·¥æ™ºèƒ½ä¸å¤§æ¨¡å‹åº”ç”¨", style: "å‰æ²¿æ¢ç´¢", personality_traits: ["æŠ€æœ¯å‰ç»", "è½åœ°å®è·µ"] }
                ];

                const agents = ref([
                    { ...expertPresets[0], model_name: "gemini-3-pro-preview" },
                    { ...expertPresets[5], model_name: "gemini-3-pro-preview" },
                    { ...expertPresets[30], model_name: "gemini-3-pro-preview" }
                ]);

                const addPresetAgent = (preset) => {
                    // Default to gemini-3-pro-preview when adding new agents
                    agents.value.push({ ...preset, model_name: "gemini-3-pro-preview" });
                    showPresetModal.value = false;
                };

                const removeAgent = (index) => {
                    agents.value.splice(index, 1);
                };

                const scrollToBottom = () => {
                    nextTick(() => {
                        const container = document.getElementById('chat-container');
                        if (container) container.scrollTop = container.scrollHeight;
                    });
                };

                // WebSocket Connection
                const connectWebSocket = () => {
                    if (websocket) return;

                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws/${encodeURIComponent(userName.value)}?session_id=${sessionId.value}`;

                    console.log("Connecting to WebSocket:", wsUrl);
                    websocket = new WebSocket(wsUrl);

                    websocket.onopen = () => {
                        console.log("WebSocket Connected");
                    };

                    websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        if (data.type === 'human_message') {
                            // Handle other users' messages
                            if (data.user_name !== userName.value) {
                                messages.value.push({
                                    type: 'human',
                                    sender: `ğŸ‘¤ ${data.user_name}`,
                                    content: data.content
                                });
                                scrollToBottom();
                            }
                        } else if (data.type === 'agent_message') {
                            // Handle agent responses to mentions
                            messages.value.push({
                                type: 'agent',
                                sender: data.sender,
                                content: data.content,
                                role: data.role || 'å›å¤@æåŠ'
                            });
                            scrollToBottom();
                        } else if (data.type === 'online_users') {
                            onlineUsers.value = data.users;
                        }
                    };
                };

                const startFullSession = async () => {
                    loading.value = true;
                    messages.value = [];
                    completedPhases.value = [];

                    try {
                        // Start session
                        const startRes = await fetch('/session/start', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                session_id: sessionId.value,
                                topic: topic.value,
                                agents: agents.value,
                                phase_rounds: phaseRounds.value
                            })
                        });

                        if (!startRes.ok) throw new Error('Failed to start session');

                        const startData = await startRes.json();
                        sessionActive.value = true;
                        currentPhase.value = startData.current_phase;
                        phaseName.value = startData.phase_name;

                        // Start streaming
                        eventSource = new EventSource(`/session/stream_full?session_id=${sessionId.value}`);

                        // Connect WebSocket for collaboration
                        connectWebSocket();

                        eventSource.addEventListener('session_start', (e) => {
                            const data = JSON.parse(e.data);
                            activeAgents.value = agents.value.map(a => ({ name: a.name, role: a.role, emotion: 'neutral' }));
                        });

                        eventSource.addEventListener('phase_start', (e) => {
                            const data = JSON.parse(e.data);
                            currentPhase.value = data.phase;
                            phaseName.value = data.name;
                            phaseEmoji.value = data.emoji;
                            messages.value.push({
                                type: 'phase',
                                content: `è¿›å…¥ ${data.name}`,
                                emoji: data.emoji
                            });
                            scrollToBottom();
                        });

                        // Handle streaming message chunks with smooth typewriter effect
                        let streamingMessage = null;
                        let chunkBuffer = ''; // Buffer to accumulate chunks
                        let typewriterInterval = null;

                        eventSource.addEventListener('message_chunk', (e) => {
                            const data = JSON.parse(e.data);

                            // If this is a new streaming message or sender changed, create a new message bubble
                            if (!streamingMessage || streamingMessage.sender !== data.sender) {
                                // CRITICAL FIX: Flush any remaining buffer to the previous message before switching
                                if (streamingMessage && chunkBuffer) {
                                    streamingMessage.content += chunkBuffer;
                                    chunkBuffer = '';
                                }

                                // Clear any existing typewriter animation
                                if (typewriterInterval) {
                                    clearInterval(typewriterInterval);
                                    typewriterInterval = null;
                                }
                                chunkBuffer = '';

                                const phaseInfo = phases.value.find(p => p.id === data.phase);
                                const newMsg = {
                                    sender: data.sender,
                                    content: '',
                                    type: data.type || 'chat',
                                    role: data.role,
                                    emotion: data.emotion,
                                    model: data.model,
                                    phase_name: phaseInfo ? phaseInfo.name : '',
                                    timestamp: new Date().toLocaleTimeString(),
                                    streaming: true
                                };
                                messages.value.push(newMsg);

                                // CRITICAL for Vue 3 Reactivity: Capture the Proxy object from the array
                                streamingMessage = messages.value[messages.value.length - 1];
                            }

                            // Add chunk to buffer
                            chunkBuffer += data.chunk;

                            // Start smooth typewriter if not already running
                            if (!typewriterInterval && streamingMessage) {
                                // CAPTURE the current message object locally to prevent null reference errors
                                // if streamingMessage variable is cleared externally
                                const targetMessage = streamingMessage;

                                typewriterInterval = setInterval(() => {
                                    if (chunkBuffer.length > 0) {
                                        // Speed up typing if buffer gets too large (adaptive speed)
                                        // If streaming is done (targetMessage.streaming is false), flush faster
                                        const isComplete = !targetMessage.streaming;
                                        const charsToTake = (chunkBuffer.length > 50 || isComplete) ? 20 : 3;

                                        const nextChars = chunkBuffer.substring(0, charsToTake);
                                        targetMessage.content += nextChars;
                                        chunkBuffer = chunkBuffer.substring(nextChars.length);
                                        scrollToBottom();
                                    } else if (!targetMessage.streaming) {
                                        // Stop ONLY when streaming is done AND buffer is empty
                                        clearInterval(typewriterInterval);
                                        typewriterInterval = null;
                                    }
                                }, 20);
                            }
                        });

                        eventSource.addEventListener('message_complete', (e) => {
                            const data = JSON.parse(e.data);

                            // Mark streaming as complete
                            // Note: We don't verify strict equality of objects because streamingMessage might be a Proxy
                            if (streamingMessage && streamingMessage.sender === data.sender) {
                                // Signal to the interval that streaming is done
                                streamingMessage.streaming = false;

                                // We DO NOT nullify streamingMessage immediately here anymore
                                // Let the interval clean itself up when buffer is empty
                                // creating a 'soft landing'
                            }

                            // Reset sender tracking only
                            if (streamingMessage && streamingMessage.sender === data.sender) {
                                streamingMessage = null;
                            }

                            typingAgent.value = null;
                        });

                        eventSource.addEventListener('message', (e) => {
                            const data = JSON.parse(e.data);
                            typingAgent.value = null;

                            const phaseInfo = phases.value.find(p => p.id === data.phase);
                            messages.value.push({
                                ...data,
                                phase_name: phaseInfo ? phaseInfo.name : ''
                            });
                            scrollToBottom();
                        });

                        eventSource.addEventListener('agent_typing', (e) => {
                            const data = JSON.parse(e.data);
                            typingAgent.value = data.agent;
                            scrollToBottom();
                        });

                        eventSource.addEventListener('phase_complete', (e) => {
                            const data = JSON.parse(e.data);
                            if (!completedPhases.value.includes(data.phase)) {
                                completedPhases.value.push(data.phase);
                            }
                        });

                        eventSource.addEventListener('phase_transition', (e) => {
                            const data = JSON.parse(e.data);
                            currentPhase.value = data.next_phase;
                            phaseName.value = data.next_name;
                        });

                        eventSource.addEventListener('generating_summary', (e) => {
                            typingAgent.value = "ğŸ“‹ ç”ŸæˆæŠ¥å‘Šä¸­";
                            scrollToBottom();
                        });

                        eventSource.addEventListener('summary', (e) => {
                            const data = JSON.parse(e.data);
                            typingAgent.value = null;
                            messages.value.push({
                                type: 'summary',
                                content: data.content
                            });
                            scrollToBottom();
                        });

                        eventSource.addEventListener('graph_update', (e) => {
                            const data = JSON.parse(e.data);
                            graphData.value = data;
                            updateGraph();
                        });

                        eventSource.addEventListener('session_complete', (e) => {
                            typingAgent.value = null;
                            loading.value = false;
                            completedPhases.value.push('output');
                            eventSource.close();
                        });

                        eventSource.onerror = (e) => {
                            console.error('SSE Error:', e);
                            loading.value = false;
                            eventSource.close();
                        };

                    } catch (error) {
                        console.error('Error:', error);
                        loading.value = false;
                        alert('å¯åŠ¨å¤±è´¥: ' + error.message);
                    }
                };

                const updateGraph = () => {
                    const elem = document.getElementById('graph');
                    if (!elem) return;

                    if (!graphInstance && graphData.value.nodes && graphData.value.nodes.length > 0) {
                        graphInstance = ForceGraph()(elem)
                            .width(elem.clientWidth)
                            .height(elem.clientHeight)
                            .graphData(graphData.value)
                            .nodeLabel(node => node.label || node.id)
                            .nodeColor(node => node.color || '#95a5a6')
                            .nodeVal(node => node.val || 5)
                            .linkColor(() => 'rgba(255,255,255,0.2)')
                            .backgroundColor('transparent');
                    } else if (graphInstance && graphData.value.nodes) {
                        graphInstance.graphData(graphData.value);
                    }
                };

                const togglePause = async () => {
                    if (isPaused.value) {
                        await fetch('/session/resume', { method: 'POST' });
                        isPaused.value = false;
                    } else {
                        // Removed confirm dialog to prevent UI blocking/flashing issue
                        await fetch('/session/pause', { method: 'POST' });
                        isPaused.value = true;
                    }
                };

                // Create new independent session in new tab
                const createNewSession = () => {
                    // Generate random 8-char string
                    const newId = Math.random().toString(36).substring(2, 10);
                    // Open in new tab with room param
                    window.open(`/?room=${newId}`, '_blank');
                };

                const resetSession = async () => {
                    // Removed confirm dialog to fix UI flash issue
                    if (eventSource) {
                        eventSource.close();
                        eventSource = null;
                    }
                    if (websocket) {
                        websocket.close();
                        websocket = null;
                    }
                    await fetch('/session/reset', { method: 'POST' });
                    await fetch('/statistics/reset', { method: 'POST' });
                    sessionActive.value = false;
                    loading.value = false;
                    messages.value = [];
                    completedPhases.value = [];
                    currentPhase.value = null;
                    graphData.value = { nodes: [], links: [] };
                    graphInstance = null;
                    isPaused.value = false;
                    typingAgent.value = null;
                    statistics.value = {};
                    onlineUsers.value = [];
                };

                // Fetch statistics from server
                const fetchStatistics = async () => {
                    try {
                        const res = await fetch('/statistics');
                        if (res.ok) {
                            statistics.value = await res.json();
                        }
                    } catch (e) {
                        console.error('Failed to fetch statistics:', e);
                    }
                };

                // Send @mention message
                const sendMentionMessage = async () => {
                    console.log("Send clicked. content:", userMessage.value);
                    if (!userMessage.value.trim()) {
                        console.log("Empty message, ignoring");
                        return;
                    }

                    const msgContent = userMessage.value;
                    const senderName = userName.value || 'ç”¨æˆ·';

                    // Clear input immediately for better UX
                    userMessage.value = '';

                    // Add user message to chat immediately
                    messages.value.push({
                        type: 'human',
                        sender: `ğŸ‘¤ ${senderName}`,
                        content: msgContent
                    });
                    scrollToBottom();

                    try {
                        const res = await fetch('/session/mention', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                sender: senderName,
                                content: msgContent
                            })
                        });

                        if (res.ok) {
                            const data = await res.json();
                            // Agent responses are handled via WebSocket 'agent_message' event
                            fetchStatistics();
                        } else {
                            const errData = await res.json().catch(() => ({}));
                            console.error('Failed to send message:', res.status);
                            alert(errData.detail || 'å‘é€å¤±è´¥ï¼Œè¯·ç¡®ä¿ä¼šè¯å·²å¯åŠ¨');
                        }
                    } catch (e) {
                        console.error('Failed to send mention:', e);
                        alert('å‘é€å‡ºé”™ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æœåŠ¡å™¨çŠ¶æ€');
                    }
                };

                // Fetch online users
                const fetchOnlineUsers = async () => {
                    try {
                        const res = await fetch('/ws/users');
                        if (res.ok) {
                            const data = await res.json();
                            onlineUsers.value = data.users || [];
                        }
                    } catch (e) {
                        console.error('Failed to fetch users:', e);
                    }
                };

                // Initialize mermaid
                if (typeof mermaid !== 'undefined') {
                    mermaid.initialize({ startOnLoad: false, theme: 'dark' });
                }

                // Markdown rendering function with syntax highlighting
                const renderMarkdown = (content) => {
                    if (!content) return '';
                    try {
                        // Configure marked with syntax highlighting
                        marked.setOptions({
                            highlight: function (code, lang) {
                                if (lang && hljs.getLanguage(lang)) {
                                    try {
                                        return hljs.highlight(code, { language: lang }).value;
                                    } catch (e) {
                                        console.error('Highlight error:', e);
                                    }
                                }
                                return hljs.highlightAuto(code).value;
                            },
                            breaks: true,
                            gfm: true
                        });

                        const html = marked.parse(content);

                        // Apply syntax highlighting to any code blocks that may have been missed
                        setTimeout(() => {
                            document.querySelectorAll('pre code').forEach((block) => {
                                if (!block.classList.contains('hljs')) {
                                    hljs.highlightElement(block);
                                }
                            });
                        }, 50);

                        return html;
                    } catch (e) {
                        console.error('Markdown rendering error:', e);
                        return content;
                    }
                };

                // Check if summary exists
                const hasSummary = computed(() => {
                    return messages.value.some(m => m.type === 'summary');
                });

                // Export summary to MD file
                // Export/View Summary Report
                const exportSummaryMD = () => {
                    console.log("Export button clicked");
                    const summaryMsg = messages.value.find(m => m.type === 'summary');
                    if (!summaryMsg) {
                        alert('æŠ¥å‘Šå°šæœªç”Ÿæˆï¼Œè¯·ç¨å€™...');
                        return;
                    }
                    console.log("Summary found, opening modal");
                    reportContent.value = summaryMsg.content;
                    showReportModal.value = true;

                    // Auto-download as fallback
                    const dateStr = new Date().toISOString().slice(0, 10);
                    downloadFile(summaryMsg.content, `innovation_report_${dateStr}.md`, 'text/markdown');

                    console.log("Modal state set to true and download triggered");
                };

                const printReport = () => {
                    window.print();
                };

                const downloadMarkdown = () => {
                    const summaryMsg = messages.value.find(m => m.type === 'summary');
                    if (!summaryMsg) return;

                    const now = new Date();
                    const dateStr = now.toISOString().slice(0, 10);

                    let content = `# ${topic.value} - åˆ›æ–°æ–¹æ¡ˆç™½çš®ä¹¦\n\n`;
                    content += `> ç”Ÿæˆæ—¶é—´: ${now.toLocaleString()}\n`;
                    content += `> å‚ä¸ä¸“å®¶: ${agents.value.map(a => a.name).join(', ')}\n\n`;
                    content += `***\n\n`;
                    content += summaryMsg.content;

                    downloadFile(content, `innovation_report_${dateStr}.md`, 'text/markdown');
                };

                const downloadPDF = () => {
                    const element = document.getElementById('report-content');
                    if (!element) return;

                    const opt = {
                        margin: [10, 10, 20, 10], // top, left, bottom, right (mm)
                        filename: `innovation_report_${new Date().toISOString().slice(0, 10)}.pdf`,
                        image: { type: 'jpeg', quality: 0.98 },
                        html2canvas: { scale: 2, useCORS: true },
                        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
                        pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
                    };

                    // Add header/footer workaround or just clean export
                    html2pdf().set(opt).from(element).save();
                };

                // Export knowledge graph to Mermaid MD
                const exportGraphMermaid = () => {
                    if (!graphData.value.nodes || graphData.value.nodes.length === 0) return;

                    const now = new Date();
                    const dateStr = now.toISOString().slice(0, 10);

                    let mermaidCode = 'graph TD\n';

                    // Add nodes
                    const nodeIds = {};
                    graphData.value.nodes.forEach((node, i) => {
                        const safeId = `N${i}`;
                        nodeIds[node.id] = safeId;
                        const label = (node.label || node.id).replace(/"/g, "'").substring(0, 30);

                        if (node.type === 'agent') {
                            mermaidCode += `    ${safeId}[["ğŸ‘¤ ${label}"]]\n`;
                        } else if (node.type === 'keyword') {
                            mermaidCode += `    ${safeId}(("ğŸ’¡ ${label}"))\n`;
                        } else {
                            mermaidCode += `    ${safeId}["${label}"]\n`;
                        }
                    });

                    mermaidCode += '\n';

                    // Add links
                    graphData.value.links.forEach(link => {
                        const sourceId = nodeIds[typeof link.source === 'object' ? link.source.id : link.source];
                        const targetId = nodeIds[typeof link.target === 'object' ? link.target.id : link.target];
                        if (sourceId && targetId) {
                            mermaidCode += `    ${sourceId} --> ${targetId}\n`;
                        }
                    });

                    // Style definitions
                    mermaidCode += '\n    classDef agent fill:#ff6b6b,stroke:#fff,color:#fff\n';
                    mermaidCode += '    classDef keyword fill:#ffe66d,stroke:#333,color:#333\n';
                    mermaidCode += '    classDef message fill:#4ecdc4,stroke:#fff,color:#fff\n';

                    // Apply styles
                    graphData.value.nodes.forEach((node, i) => {
                        const safeId = `N${i}`;
                        if (node.type === 'agent') {
                            mermaidCode += `    class ${safeId} agent\n`;
                        } else if (node.type === 'keyword') {
                            mermaidCode += `    class ${safeId} keyword\n`;
                        } else {
                            mermaidCode += `    class ${safeId} message\n`;
                        }
                    });

                    let mdContent = `# å¤´è„‘é£æš´çŸ¥è¯†å›¾è°±\n\n`;
                    mdContent += `**ä¸»é¢˜**: ${topic.value}\n`;
                    mdContent += `**ç”Ÿæˆæ—¶é—´**: ${now.toLocaleString('zh-CN')}\n\n`;
                    mdContent += `## å›¾è°±å¯è§†åŒ–\n\n`;
                    mdContent += '```mermaid\n' + mermaidCode + '```\n\n';
                    mdContent += `## èŠ‚ç‚¹è¯´æ˜\n\n`;
                    mdContent += `- ğŸ”´ **çº¢è‰²èŠ‚ç‚¹**: å‚ä¸ä¸“å®¶\n`;
                    mdContent += `- ğŸŸ¡ **é»„è‰²èŠ‚ç‚¹**: å…³é”®è¯/æ¦‚å¿µ\n`;
                    mdContent += `- ğŸ”µ **é’è‰²èŠ‚ç‚¹**: è®¨è®ºå†…å®¹\n`;

                    downloadFile(mdContent, `knowledge_graph_${dateStr}.md`, 'text/markdown');
                };

                // Export Mindmap (Mermaid)
                const exportMindMap = () => {
                    if (!graphData.value.nodes || graphData.value.nodes.length === 0) {
                        alert("æš‚æ— æ•°æ®å¯å¯¼å‡º");
                        return;
                    }

                    const now = new Date();
                    const dateStr = now.toISOString().slice(0, 10);

                    let mmCode = 'mindmap\n';
                    mmCode += `  root((${topic.value || 'Central Topic'}))\n`;

                    // Group 1: Agents
                    mmCode += `    ::icon(fa fa-users)\n`;
                    mmCode += `    Agents\n`;
                    agents.value.forEach(a => {
                        let name = a.name.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '');
                        if (name) {
                            mmCode += `      ${name}\n`;
                            mmCode += `        ::icon(fa fa-user)\n`;
                        }
                    });

                    // Group 2: Key Concepts (from keywords nodes in graph)
                    mmCode += `    Concepts\n`;
                    mmCode += `      ::icon(fa fa-lightbulb)\n`;

                    // Filter just keyword nodes
                    const keywords = graphData.value.nodes.filter(n => n.type === 'keyword').slice(0, 15); // Top 15
                    keywords.forEach(kw => {
                        const val = kw.id.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '');
                        if (val) mmCode += `      ${val}\n`;
                    });

                    let mdContent = `# å¤´è„‘é£æš´æ€ç»´å¯¼å›¾\n\n`;
                    mdContent += '```mermaid\n' + mmCode + '```\n\n';

                    downloadFile(mdContent, `mindmap_${dateStr}.md`, 'text/markdown');
                };

                // Export graph as PNG
                const exportGraphImage = async () => {
                    const graphEl = document.getElementById('graph');
                    if (!graphEl) return;

                    try {
                        const canvas = await html2canvas(graphEl, {
                            backgroundColor: '#0f172a', // Dark theme background
                            logging: false
                        });

                        const link = document.createElement('a');
                        const dateStr = new Date().toISOString().slice(0, 10);
                        link.download = `knowledge_graph_${dateStr}.png`;
                        link.href = canvas.toDataURL();
                        link.click();
                    } catch (e) {
                        console.error("Failed to export image:", e);
                        alert("å¯¼å‡ºå›¾ç‰‡å¤±è´¥ï¼Œè¯·é‡è¯•");
                    }
                };

                // Export Full Chat Log
                const exportFullChat = () => {
                    if (messages.value.length === 0) {
                        alert("æš‚æ— å¯¹è¯è®°å½•");
                        return;
                    }

                    let content = `# Brainstorming Session Log: ${topic.value || 'Untitled'}\n`;
                    content += `Date: ${new Date().toLocaleString()}\n\n`;
                    content += `---\n\n`;

                    messages.value.forEach(msg => {
                        const sender = msg.sender || "System";
                        const text = msg.content || "";
                        content += `### ${sender}\n${text}\n\n`;
                        content += `---\n\n`;
                    });

                    const dateStr = new Date().toISOString().slice(0, 10);
                    downloadFile(content, `session_log_${dateStr}.md`, 'text/markdown');
                };

                // Helper function to download file
                const downloadFile = (content, filename, mimeType) => {
                    const blob = new Blob([content], { type: mimeType + ';charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };

                const fetchModels = async () => {
                    try {
                        const res = await fetch('/models');
                        if (res.ok) {
                            const data = await res.json();
                            if (data.models && data.models.length > 0) {
                                availableModels.value = data.models;
                            }
                        }
                    } catch (e) {
                        console.error("Failed to fetch models:", e);
                    }
                };

                return {
                    sessionActive, loading, topic, messages, typingAgent,
                    currentPhase, phaseName, phaseEmoji, completedPhases,
                    activeAgents, graphData, showPresetModal, phases,
                    agents, expertPresets, phaseRounds, isPaused, hasSummary,
                    statistics, onlineUsers, userName, userMessage,
                    showReportModal, reportContent, availableModels,
                    currentTab, pastSessions, fetchSessions, loadSessionHistory, // Added History vars
                    addPresetAgent, removeAgent, startFullSession,
                    increaseRounds, decreaseRounds, togglePause, resetSession,
                    renderMarkdown, exportSummaryMD, exportGraphMermaid, exportGraphImage, exportFullChat,
                    fetchStatistics, sendMentionMessage, fetchOnlineUsers, createNewSession,
                    printReport, downloadMarkdown, downloadPDF, exportMindMap
                };
            }
        });

        const vm = app.mount('#app');
        window.vm = vm;
    </script>
</body>

</html>